{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DataMat Documentation","text":"<p>DataMat provides <code>DataVec</code> and <code>DataMat</code> objects\u2014thin wrappers around pandas Series/DataFrames\u2014that preserve labels while supporting linear-algebra operations. This documentation covers installation, quick-start examples, API reference, and design notes collected during development.</p> <pre><code>import datamat as dm\n\nA = dm.DataMat([[1, 2], [3, 4]], idxnames=[\"i\"], colnames=[\"j\"])\nb = dm.DataVec([1, 1], idxnames=[\"j\"], name=\"weights\")\n\nresult = A @ b\nprint(result)\n</code></pre> <p>Use the navigation on the left to explore guides, API details, and background notes.</p>"},{"location":"api/datamat/","title":"DataMat API","text":"<p><code>DataMat</code> extends <code>pandas.DataFrame</code> with matrix-oriented operations that retain labels. The section below is rendered from the live docstrings.</p> <p>               Bases: <code>DataFrame</code></p> <p>Matrix with labeled rows and columns supporting linear algebra semantics.</p>"},{"location":"api/datamat/#datamat.core.DataMat.leverage","title":"<code>leverage</code>  <code>cached</code> <code>property</code>","text":"<p>Return leverage of matrix (diagonal of projection matrix).</p> <p>DataMat([[1,2],[3,4],[5,6]],idxnames='i').leverage()</p>"},{"location":"api/datamat/#datamat.core.DataMat.pinv","title":"<code>pinv</code>  <code>cached</code> <code>property</code>","text":"<p>Moore-Penrose pseudo-inverse.</p>"},{"location":"api/datamat/#datamat.core.DataMat.vec","title":"<code>vec</code>  <code>property</code>","text":"<p>Column-stacked vectorisation vec(M).</p>"},{"location":"api/datamat/#datamat.core.DataMat.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>X.getitem(k) == X[k]</p> <p>X = DataMat([[1,2,3],[4,5,6]],colnames='cols',idxnames='rows') X[0].sum().squeeze()==5 True</p>"},{"location":"api/datamat/#datamat.core.DataMat.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Create a DataMat.</p> <p>Inherit from :meth: <code>pd.DataFrame.__init__</code>.</p>"},{"location":"api/datamat/#datamat.core.DataMat.__init__--additional-parameters","title":"Additional Parameters","text":"<p>idxnames         (List of) name(s) for levels of index. colnames         (List of) name(s) for levels of columns. name         String naming DataMat object.</p>"},{"location":"api/datamat/#datamat.core.DataMat.concat","title":"<code>concat(other, axis=0, levelnames=False, toplevelname='v', suffixer='_', drop_vestigial_levels=False, **kwargs)</code>","text":"<p>Concatenate self and other.</p> <p>This uses the machinery of pandas.concat, but ensures that when two DataMats having multiindices with different number of levels are concatenated that new levels are added so as to preserve a result with a multiindex.</p> <p>if other is a dictionary and levelnames is not False, then a new level in the multiindex is created naming the columns belonging to the original DataMats.</p>"},{"location":"api/datamat/#datamat.core.DataMat.concat--usage","title":"USAGE","text":"<p>a = DataVec([1,2],name='a',idxnames='i') b = DataMat([[1,2],[3,4]],name='b',idxnames='i',colnames='j') b.concat([a,b],axis=1,levelnames=True).columns.levels[0].tolist() ['b', 'a', 'b_0']</p>"},{"location":"api/datamat/#datamat.core.DataMat.dg","title":"<code>dg()</code>","text":"<p>Return the diagonal vector diag(M) of a square matrix.</p>"},{"location":"api/datamat/#datamat.core.DataMat.drop_vestigial_levels","title":"<code>drop_vestigial_levels(axis=None)</code>","text":"<p>Drop index &amp; column levels that don't vary.</p> <p>Takes a single optional parameter: - axis (default None): If axis=0, operate on index;   if 1, on columns; if None, on both.</p>"},{"location":"api/datamat/#datamat.core.DataMat.eig","title":"<code>eig(hermitian=False, ascending=True)</code>","text":"<p>Eigendecomposition.  Returns eigenvalues &amp; corresponding eigenvectors.</p>"},{"location":"api/datamat/#datamat.core.DataMat.from_jax","title":"<code>from_jax(wrapper)</code>  <code>classmethod</code>","text":"<p>Rebuild a :class:<code>DataMat</code> from a :class:<code>DataMatJax</code> wrapper.</p>"},{"location":"api/datamat/#datamat.core.DataMat.matmul","title":"<code>matmul(other, strict=False, fillmiss=False)</code>","text":"<p>Matrix product preserving labels on the surviving axes.</p>"},{"location":"api/datamat/#datamat.core.DataMat.norm","title":"<code>norm(ord=None, **kwargs)</code>","text":"<p>Matrix norm \u2016M\u2016_ord mirroring :func:<code>numpy.linalg.norm</code>.</p>"},{"location":"api/datamat/#datamat.core.DataMat.proj","title":"<code>proj(other)</code>","text":"<p>Linear projection of self on other.</p>"},{"location":"api/datamat/#datamat.core.DataMat.random","title":"<code>random(shape, distribution='normal', *, index=None, columns=None, idxnames=None, colnames=None, rng=None, name=None, **dist_kwargs)</code>  <code>classmethod</code>","text":"<p>Draw a random matrix with optional labelled axes.</p>"},{"location":"api/datamat/#datamat.core.DataMat.random--parameters","title":"Parameters","text":"<p>shape : tuple[int, int]     Number of rows and columns. distribution : random-spec, default \"normal\"     Name/tuple/callable describing the distribution. Supports the     same shorthands as :meth:<code>DataVec.random</code> (normal, uniform, chi-square,     exponential, Bernoulli, binomial, Poisson, etc.). index, columns : sequence or pandas.Index, optional     Labels for rows/columns; defaults to simple RangeIndex. idxnames, colnames : str or sequence of str, optional     Names applied to the index/column levels. rng : numpy.random.Generator | int | None, optional     RNG or seed used by the draw. name : str, optional     Matrix name. **dist_kwargs     Additional keyword arguments forwarded to the distribution.</p>"},{"location":"api/datamat/#datamat.core.DataMat.random--returns","title":"Returns","text":"<p>DataMat     Labelled matrix of shape <code>shape</code>.</p>"},{"location":"api/datamat/#datamat.core.DataMat.rank","title":"<code>rank(**kwargs)</code>","text":"<p>Matrix rank</p>"},{"location":"api/datamat/#datamat.core.DataMat.resid","title":"<code>resid(other)</code>","text":"<p>Residual from projection of self on other.</p>"},{"location":"api/datamat/#datamat.core.DataMat.set_index","title":"<code>set_index(columns, levels=None, inplace=False)</code>","text":"<p>Set the DataMat index using existing columns.</p> <p>X = DataMat([[1,2,3],[4,5,6]],columns=['a','b','c'],colnames='cols',idxnames='rows') X.set_index(['a','b'])</p>"},{"location":"api/datamat/#datamat.core.DataMat.svd","title":"<code>svd(hermitian=False)</code>","text":"<p>Singular value composition into U@S.dg@V.T.</p>"},{"location":"api/datamat/#datamat.core.DataMat.to_jax","title":"<code>to_jax(*, dtype=float)</code>","text":"<p>Convert the matrix into a JAX-compatible wrapper retaining labels.</p>"},{"location":"api/datamat/#datamat.core.DataMat.tril","title":"<code>tril(k=0)</code>","text":"<p>Return lower triangular part as DataMat, preserving labels.</p>"},{"location":"api/datamat/#datamat.core.DataMat.triu","title":"<code>triu(k=0)</code>","text":"<p>Return upper triangular part as DataMat, preserving labels.</p>"},{"location":"api/datavec/","title":"DataVec API","text":"<p><code>DataVec</code> extends <code>pandas.Series</code> with linear-algebra friendly behaviour. The reference below is generated directly from the docstrings, so it stays in sync with the code.</p> <p>               Bases: <code>Series</code></p> <p>Column vector with labeled index for linear-algebra operations.</p>"},{"location":"api/datavec/#datamat.core.DataVec.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>v.getitem(k) == v[k]</p> <p>v = DataVec({'a':1,'b':2}) v['a'] 1</p>"},{"location":"api/datavec/#datamat.core.DataVec.__init__","title":"<code>__init__(data=None, **kwargs)</code>","text":"<p>Create a DataVec.</p> <p>Inherit from :meth: <code>pd.Series.__init__</code>.</p>"},{"location":"api/datavec/#datamat.core.DataVec.__init__--additional-parameters","title":"Additional Parameters","text":"<p>idxnames         (List of) name(s) for levels of index.</p>"},{"location":"api/datavec/#datamat.core.DataVec.dg","title":"<code>dg(sparse=True)</code>","text":"<p>Return the diagonal matrix diag(v).</p>"},{"location":"api/datavec/#datamat.core.DataVec.drop_vestigial_levels","title":"<code>drop_vestigial_levels()</code>","text":"<p>Drop index levels that don't vary.</p>"},{"location":"api/datavec/#datamat.core.DataVec.inv","title":"<code>inv()</code>","text":"<p>Inverse of a vector defined for 1-vector case.</p>"},{"location":"api/datavec/#datamat.core.DataVec.norm","title":"<code>norm(ord=None, **kwargs)</code>","text":"<p>Vector norm \u2016v\u2016_ord (defaults to the Euclidean norm).</p>"},{"location":"api/datavec/#datamat.core.DataVec.outer","title":"<code>outer(other)</code>","text":"<p>Outer product of two series (vectors).</p>"},{"location":"api/datavec/#datamat.core.DataVec.proj","title":"<code>proj(other)</code>","text":"<p>Projection of self on other.</p>"},{"location":"api/datavec/#datamat.core.DataVec.random","title":"<code>random(size, distribution='normal', *, index=None, idxnames=None, name=None, rng=None, **dist_kwargs)</code>  <code>classmethod</code>","text":"<p>Draw a random vector with optional labelled index.</p>"},{"location":"api/datavec/#datamat.core.DataVec.random--parameters","title":"Parameters","text":"<p>size : int     Length of the vector. distribution : random-spec, default \"normal\"     Name/tuple/callable describing the distribution. Built-in shorthands:       - <code>\"normal\"</code> / <code>\"gaussian\"</code> (loc, scale)       - <code>\"uniform\"</code> (low, high)       - <code>\"chi2\"</code> / <code>\"chisquare\"</code> (df)       - <code>\"exponential\"</code> (scale)       - <code>\"bernoulli\"</code> (p)       - <code>\"binomial\"</code> (n, p)       - <code>\"poisson\"</code> (lam)       - <code>\"standard_normal\"</code>     A tuple like <code>(\"chi2\", 3)</code> maps to the appropriate parameters.     Custom callables must accept <code>size=</code> and return an array. index : Sequence or pandas.Index, optional     Values for the index; defaults to 0..size-1. idxnames : str or sequence of str, optional     Name(s) applied to the index levels. name : str, optional     Vector name; defaults to an auto-generated <code>vec_*</code> identifier. rng : numpy.random.Generator | int | None, optional     RNG or seed used by the draw (falls back to <code>default_rng()</code>). **dist_kwargs     Additional keyword arguments forwarded to the distribution.</p>"},{"location":"api/datavec/#datamat.core.DataVec.random--returns","title":"Returns","text":"<p>DataVec     Labelled random vector of shape <code>(size,)</code>.</p>"},{"location":"api/datavec/#datamat.core.DataVec.resid","title":"<code>resid(other)</code>","text":"<p>Residual from projection of self on other.</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":""},{"location":"guide/getting-started/#installation","title":"Installation","text":"<p>DataMat is distributed on PyPI. Use Poetry or pip:</p> <pre><code>pip install datamat\n# or\npoetry add datamat\n</code></pre>"},{"location":"guide/getting-started/#basic-usage","title":"Basic Usage","text":"<p>Create labelled matrices and vectors using familiar pandas-like constructors. All operations preserve index/column metadata automatically.</p> <pre><code>import datamat as dm\nimport numpy as np\n\nrows = [\"obs1\", \"obs2\"]\ncols = [\"x1\", \"x2\"]\n\nX = dm.DataMat(np.array([[1.0, 2.0], [3.0, 4.0]]), idxnames=[\"obs\"], colnames=[\"feature\"], index=rows, columns=cols)\ny = dm.DataVec([1.0, 0.5], idxnames=[\"feature\"], name=\"coef\")\n\nprediction = X @ y\nprint(prediction)\n</code></pre>"},{"location":"guide/getting-started/#random-draws","title":"Random Draws","text":"<p>Use the random helpers to simulate labelled data:</p> <pre><code>X = dm.DataMat.random((100, 3), distribution=\"normal\", idxnames=[\"obs\"], colnames=[\"feature\"], rng=123)\ny = dm.DataVec.random(100, distribution=(\"normal\", 0, 2), idxnames=[\"obs\"], rng=456)\n</code></pre>"},{"location":"guide/getting-started/#documentation-build","title":"Documentation Build","text":"<p>The documentation you are reading is generated by MkDocs (Material theme). To build locally:</p> <pre><code>pip install -r docs/requirements.txt\nmkdocs serve\n</code></pre> <p>Navigate to http://127.0.0.1:8000/ in your browser.</p>"},{"location":"notes/norms/","title":"Norm Conventions","text":"<p><code>DataVec.norm</code> and <code>DataMat.norm</code> follow NumPy's conventions while preserving labels.</p>"},{"location":"notes/norms/#vector-norms-datavecnorm","title":"Vector Norms (<code>DataVec.norm</code>)","text":"<ul> <li><code>ord=2</code> (default): Euclidean norm (|v|_2 = \\sqrt{\\sum_i v_i^2}).</li> <li><code>ord=1</code>: Manhattan norm (\\sum_i |v_i|).</li> <li><code>ord=\\infty</code>: maximum absolute entry.</li> <li><code>ord=0</code>: count of non-zero elements.</li> <li>Negative orders and other values behave exactly like <code>numpy.linalg.norm</code>.</li> </ul>"},{"location":"notes/norms/#matrix-norms-datamatnorm","title":"Matrix Norms (<code>DataMat.norm</code>)","text":"<ul> <li><code>ord=None</code> or <code>'fro'</code>: Frobenius norm (|A|F = \\sqrt{\\sum{i,j} a_{ij}^2}).</li> <li><code>ord=1</code>: induced column-sum norm (\\max_j \\sum_i |a_{ij}|).</li> <li><code>ord=\\infty</code>: induced row-sum norm (\\max_i \\sum_j |a_{ij}|).</li> <li><code>ord=2</code>: spectral norm (largest singular value).</li> <li><code>ord='nuc'</code>: nuclear norm (sum of singular values).</li> <li>Any other options are forwarded to <code>numpy.linalg.norm</code>.</li> </ul> <p>Remember that calling these methods returns scalars; the underlying labels remain available on the original objects.</p>"}]}